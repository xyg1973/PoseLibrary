
# Form implementation generated from reading ui file 'cv_smooth.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PySide2 import QtCore, QtGui, QtWidgets
from PySide2 import shiboken2
from pymxs import runtime as rt
import pymxs

class PyMaxDockWidget(QtWidgets.QDockWidget):
    def __init__(self, parent=None):
        super(PyMaxDockWidget, self).__init__(parent)
        self.setWindowFlags(QtCore.Qt.Tool)
        # self.setWindowTitle('Pyside Qt  Dock Window')
        self.setupUi(self)
        self.creat_contion()

    def setupUi(self, Frame):
        Frame.setObjectName("Frame")
        Frame.resize(276, 78)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(Frame)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalSlider = QtWidgets.QSlider(Frame)
        self.horizontalSlider.setPageStep(1)
        self.horizontalSlider.setProperty("value", 20)
        self.horizontalSlider.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider.setObjectName("horizontalSlider")
        self.verticalLayout.addWidget(self.horizontalSlider)
        self.pushButton = QtWidgets.QPushButton(Frame)
        self.pushButton.setStyleSheet("QPushButton {\n"
"    background-color:rgb(40, 105, 254);\n"
"    color: rgb(255, 255, 255);\n"
"    border-width: 0px;\n"
"    border-radius: 3px;\n"
"    border-color: beige;\n"
"    padding: 2px;\n"
"\n"
"}\n"
"QPushButton:hover {\n"
"    background-color:rgb(14, 59, 229);\n"
"}\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 33, 154);\n"
"    border-style: inset;\n"
"}\n"
"\n"
"\n"
"")
        self.pushButton.setObjectName("pushButton")
        self.verticalLayout.addWidget(self.pushButton)
        self.verticalLayout_2.addLayout(self.verticalLayout)


        #--------------------------------------

        self.pushButton.setFocusPolicy(QtCore.Qt.NoFocus)
        self.horizontalSlider.setFocusPolicy(QtCore.Qt.NoFocus)
        self.verticalLayout.setSpacing(15)
        widget = QtWidgets.QWidget()
        widget.setLayout(self.verticalLayout_2)
        self.setWidget(widget)
        # self.resize(250, 100)
        #-----------------------------------------------
        self.retranslateUi(Frame)
        QtCore.QMetaObject.connectSlotsByName(Frame)

    def retranslateUi(self, Frame):
        _translate = QtCore.QCoreApplication.translate
        Frame.setWindowTitle(_translate("Frame", "曲线平滑"))
        self.pushButton.setText(_translate("Frame", "smooth"))

    def creat_contion(self):
        self.pushButton.clicked.connect(self.Apply_smooth)

    def get_TrackView_SelectKeys(self,obj):
        """
        return:列表，列表元素是字典，字典记录的，每条曲线的控制器“controller”和选中的帧列表“selkeys”
        """
        allselectkeys = []
        for i in range(obj.numsubs):
            sub = rt.getSubAnim(obj, i + 1)
            # print(f'{sub.name} [{sub_i+1}]')

            if sub.controller == None:
                pass
                # print(i+1)
                # print(' No controller assigned to it')
            else:
                # print(i+1)
                # print("current controller: {}".format(sub.controller))
                if sub.keys == None:
                    pass
                    # print("No keys assigned to it")
                for secsub_i in range(sub.numsubs):
                    secsub = rt.getSubAnim(sub, secsub_i + 1)
                    # print(secsub)
                    if secsub.controller == None:
                        pass
                        # print('\t No controller assigned to it')
                    else:
                        pass
                        # print('\t current controller: {}'.format(secsub.controller))
                    if secsub.keys == None:
                        pass
                        # print('\t No keys assigned to it')
                    for thirdsub_i in range(secsub.numsubs):
                        thirdsub = rt.getSubAnim(secsub, thirdsub_i + 1)
                        # print('\t\t{} [{}]'.format(thirdsub.name, thirdsub_i + 1))
                        if secsub.controller == None:
                            pass
                            # print('\t No controller assigned to it')
                        else:
                            keydirt = {}
                            keydirt["controller"] = thirdsub.controller

                            # print('\t\t current controller: {}'.format(thirdsub.controller))
                            # print(rt.numSelKeys(thirdsub.controller))
                            selkeys = []
                            for numkeys in range(rt.numKeys(thirdsub.controller)):
                                # print(thirdsub.controller.keys)
                                # print(numkeys)
                                if rt.isKeySelected(thirdsub.controller, numkeys + 1):
                                    selkey = rt.getKey(thirdsub.controller, numkeys + 1)
                                    selkeys.append(selkey)
                            keydirt["selkeys"] = selkeys
                            # print(keydirt)
                            allselectkeys.append(keydirt)
        return allselectkeys

    def ls(self):
        allobj = []
        objs = rt.selection
        for obj in objs:
            allobj.append(obj)
        return allobj
    def Apply_smooth(self):
        #获取滑块数值
        #滑块数值归一化
        slidervalue = self.horizontalSlider.value()*0.01
        objs = self.ls()

        for obj in objs:
            data = []
            data  = self.get_TrackView_SelectKeys(obj)
            for i in range(len(data)):
                selkeys = data[i]["selkeys"]
                objcontroller = data[i]["controller"]

                if len(selkeys) >=3:
                    Timestart = selkeys[0].time
                    Timeend = selkeys[len(selkeys)-1].time
                    Timestart_value = selkeys[0].value
                    Timeend_value = selkeys[len(selkeys)-1].value

                    Accelerated_speed = (Timeend_value - Timestart_value) / int(Timeend - Timestart)
                    v0 = Timeend_value - Accelerated_speed *int(Timeend)

                    print(Accelerated_speed)
                    k =0
                    for key in selkeys:
                        if k ==0:
                            k+=1
                            pass
                        elif k == len(selkeys)-1:
                            pass
                        else:
                            key_value = key.value
                            key_value_time = key.time
                            key_new_value = Accelerated_speed*int(key.time)+v0
                            key_new_value = (key.value-key_new_value)*(1-slidervalue) + key_new_value
                            # setkeyvalue = key_new_value
                            with pymxs.animate(True):
                                with pymxs.redraw(True):
                                    with pymxs.attime(key.time):
                                        objcontroller.value = key_new_value
                                        # print(objcontroller.value)
                            k+=1



            # print(data)
            # if len(data["selkeys"]) >=3:
            #     print("yes,yes,yes")
            # print(data)


        # #获取key_value的开始帧值和结束帧值
        # Timestart = ""
        # Timeend = ""
        # Timestart_value =""
        # Timeend_value = ""
        #
        #
        # #计算加速度
        # Accelerated_speed = (Timeend_value-Timestart_value)/(Timeend-Timestart)
        #
        # for key in selectkeys:
        #     if i ==0:
        #         pass
        #     elif key == len(selectkeys):
        #         pass
        #     else:
        #         key_value = keyvalus
        #         key_value_time = key.time
        #         key_new_value = keyvalus/(Accelerated_speed*key.time)*slidervalue
        #         setkeyvalue = key_new_value
        #
        # print(slidervalue)

def main():


    #rt.resetMaxFile(rt.name('noPrompt'))
    # Cast the main window HWND to a QMainWindow for docking
    # First, get the QWidget corresponding to the Max windows HWND:
    main_window_qwdgt = QtWidgets.QWidget.find(rt.windows.getMAXHWND())
    # Then cast it as a QMainWindow for docking purposes:
    main_window = shiboken2.wrapInstance(shiboken2.getCppPointer(main_window_qwdgt)[0], QtWidgets.QMainWindow)
    w = PyMaxDockWidget(parent=main_window)
    w.setFloating(True)
    w.show()

if __name__ == "__main__":
    main()